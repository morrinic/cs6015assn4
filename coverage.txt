    1|       |//
    2|       |//  main.cpp
    3|       |//  Classifying Quadrilaterals Program
    4|       |//
    5|       |//  Created by Nicole Morris on 1/16/19.
    6|       |//  Copyright Â© 2019 Nicole Morris. All rights reserved.
    7|       |//
    8|       |
    9|       |#include <iostream>
   10|       |#include <vector>
   11|       |#include <fstream>
   12|       |#include <math.h>
   13|       |#include <sstream>
   14|       |
   15|       |struct Point {double x; double y;};
   16|       |struct Angle {Point a; Point b; Point c; float degrees;};
   17|       |struct Quad {float ab; float bc; float cd; float da; Angle a; Angle b; Angle c; Angle d;};
   18|       |
   19|       |/*
   20|       | * MATH FXNS
   21|       | * Used to find components quadrilateral features (side length, angle degrees, side slope)
   22|       | */
   23|       |
   24|       |//Calculates the length of a line between 2 xy coordinates
   25|       |//Modified from www.geeksforgeeks.org/program-calculate-distance-two-points/
   26|    112|float calcLength(Point a, Point b){
   27|    112|    
   28|    112|    return sqrt(pow(b.x - a.x,2) + pow(b.y-a.y,2));
   29|    112|}
   30|       |
   31|       |//Calculates the value of degress based on 3 xy coordinates
   32|       |//Modified from www.geeksforgeeks.org/find-angles-given-triangle/
   33|     28|float calcDeg(Point a, Point b, Point c){
   34|     28|    
   35|     28|    double pi = 3.1415926535;
   36|     28|    float sideAB = calcLength(a,b);
   37|     28|    float sideBC = calcLength(b,c);
   38|     28|    float sideCA = calcLength(c,a);
   39|     28|    
   40|     28|    return (180 / pi * (acos((pow(sideAB,2) + pow(sideBC,2) - pow(sideCA,2)) / (2 * sideAB * sideBC))));
   41|     28|    
   42|     28|}
   43|       |
   44|       |//Calculates the slope of a line
   45|       |//Modified from www.geeksforgeeks.org/program-find-slope-line/
   46|     10|float slope(float ax, float ay, float bx, float by){
   47|     10|    
   48|     10|    return (by - ay) / (bx - ax);
   49|     10|    
   50|     10|}
   51|       |
   52|       |/*
   53|       | * CLASSIFICATION FXNS
   54|       | * Determines the type of quadrilateral (square, rhombus, rectangle, parallelogram, kite, trapezoid, quadrilateral)
   55|       | */
   56|       |
   57|       |//Determines if a quadrilateral is a parallelogram
   58|      7|bool isParallelogram(Quad quad){
   59|      7|    
   60|      7|    //Opposite sides are congruent
   61|      7|    if(quad.ab == quad.cd && quad.bc == quad.da){
   62|      4|        return true;
   63|      4|    }
   64|      3|    
   65|      3|    return false;
   66|      3|}
   67|       |
   68|       |//Determines if a parallelogram is a rhombus
   69|      4|bool isRhombus(Quad quad){
   70|      4|    
   71|      4|    if(quad.ab == quad.bc){
   72|      2|        if(quad.bc == quad.cd){
   73|      2|            if(quad.cd == quad.da){
   74|      2|                if(quad.da == quad.ab){
   75|      2|                    return true;
   76|      2|                }
   77|      2|            }
   78|      2|            
   79|      2|        }
   80|      2|    }
   81|      2|    
   82|      2|    return false;
   83|      2|}
   84|       |
   85|       |//Determines if a parallelogram is a rectangle
   86|      4|bool isRectangle(Quad quad){
   87|      4|    
   88|      4|    if(quad.a.degrees == quad.b.degrees){
   89|      2|        if(quad.b.degrees == quad.c.degrees){
   90|      2|            if(quad.c.degrees == quad.d.degrees){
   91|      2|                if(quad.d.degrees == quad.a.degrees){
   92|      2|                    return true;
   93|      2|                }
   94|      2|            }
   95|      2|        }
   96|      2|    }
   97|      2|    
   98|      2|    return false;
   99|      2|}
  100|       |
  101|       |//Determines if a rhombus or rectangle is a square
  102|      2|bool isSquare(Quad quad){
  103|      2|    
  104|      2|    //Already classified as a rhombus so...
  105|      2|    return isRectangle(quad);
  106|      2|    
  107|      2|}
  108|       |
  109|       |//Determines if a quadrilateral is a kite
  110|      3|bool isKite(Quad quad){
  111|      3|    
  112|      3|    if((quad.ab == quad.bc && quad.cd == quad.da) || (quad.ab == quad.da && quad.bc == quad.cd)){
  113|      1|        return true;
  114|      1|    }
  115|      2|    return false;
  116|      2|}
  117|       |
  118|       |//Determines if a quadrilateral is a trapezoid
  119|      2|bool isTrapezoid(Quad quad){
  120|      2|    
  121|      2|    if(slope(quad.a.b.x,quad.a.b.y,quad.b.b.x,quad.b.b.y) == slope(quad.d.b.x,quad.d.b.y,quad.c.b.x,quad.c.b.y)){
  122|      0|        if(!(slope(quad.b.b.x,quad.b.b.y,quad.c.b.x,quad.c.b.y) == slope(quad.a.b.x,quad.a.b.y,quad.d.b.x,quad.d.b.y))){
  123|      0|            return true;
  124|      0|        }
  125|      2|    } else if (slope(quad.b.b.x,quad.b.b.y,quad.c.b.x,quad.c.b.y) == slope(quad.a.b.x,quad.a.b.y,quad.d.b.x,quad.d.b.y)){
  126|      1|        if(!(slope(quad.a.b.x,quad.a.b.y,quad.b.b.x,quad.b.b.y) == slope(quad.d.b.x,quad.d.b.y,quad.c.b.x,quad.c.b.y))){
  127|      1|            return true;
  128|      1|        }
  129|      1|    }
  130|      1|    
  131|      1|    return false;
  132|      1|    
  133|      1|}
  134|       |
  135|       |//Prints the classification of a parallelogram
  136|      4|void classifyParallel(Quad quad){
  137|      4|    //If parallelogram, determine if rhombus
  138|      4|    if(isRhombus(quad)){
  139|      2|        
  140|      2|        //If rhombus, determine if square
  141|      2|        if(isSquare(quad)){
  142|      1|            std:: cout << "square\n";
  143|      1|        } else {
  144|      1|            std:: cout << "rhombus\n";
  145|      1|        }
  146|      2|        
  147|      2|    } else {
  148|      2|        //Confirm is a rectangle
  149|      2|        
  150|      2|        if(isRectangle(quad)){
  151|      1|            std:: cout << "rectangle\n";
  152|      1|            
  153|      1|        } else {
  154|      1|            
  155|      1|            //If not rhombus or rectangle...
  156|      1|            std:: cout << "parallelogram\n";
  157|      1|            
  158|      1|        }
  159|      2|    }
  160|      4|}
  161|       |
  162|       |//Prints the classification of a quadrilateral that is not a parallelogram
  163|      3|void classifyNotParallel(Quad quad){
  164|      3|    if(isKite(quad)){
  165|      1|        std::cout << "kite\n";
  166|      2|    } else if(isTrapezoid(quad)){
  167|      1|        std::cout << "trapezoid\n";
  168|      1|    } else {
  169|      1|        std::cout << "quadrilateral\n";
  170|      1|    }
  171|      3|}
  172|       |
  173|       |//Prints the classification of a quadrilateral
  174|      7|void classifyQuad(Quad quad){
  175|      7|    
  176|      7|    //Determine if parallelogram
  177|      7|    if(isParallelogram(quad)){
  178|      4|        classifyParallel(quad);
  179|      4|    } else {
  180|      3|        
  181|      3|        classifyNotParallel(quad);
  182|      3|    }
  183|      7|}
  184|       |
  185|       |/*
  186|       | * ERROR CHECKING FUNCTIONS
  187|       | */
  188|       |
  189|    200|void error(std::string message){
  190|    200|    std::cout << message << std::endl;
  191|    200|    exit(1);
  192|    200|}
  193|       |
  194|    207|void checkLength(std::vector<std::string> lines){
  195|    207|    
  196|    207|    static int length = lines.size();
  197|    207|    
  198|    207|    //Check number of points
  199|    207|    if(length < 6 | length > 6){
  200|      0|        error("error 1");
  201|      0|    }
  202|    207|    
  203|    207|}
  204|       |
  205|    107|void checkRange(double digits[6]){
  206|    107|    
  207|    749|    for(int i = 0; i < 6; i++){
  208|    642|        if(digits[i] < 0| digits[i] >100){
  209|      0|            error("error 1");
  210|      0|        }
  211|    642|    }
  212|    107|    
  213|    107|}
  214|       |
  215|    428|bool isSamePoint(Point a, Point b){
  216|    428|    if(a.x == b.x && a.y == b.y){
  217|    100|        return true;
  218|    100|    }
  219|    328|    return false;
  220|    328|}
  221|       |
  222|    107|void checkPointColl(Point a, Point b, Point c, Point d){
  223|    107|    
  224|    107|    if(isSamePoint(a,b) | isSamePoint(b,c) | isSamePoint(c,d) | isSamePoint(d,a)){
  225|    100|        error("error 2");
  226|    100|        exit(1);
  227|    100|    }
  228|    107|    
  229|    107|}
  230|       |
  231|       |//Modified from www.geeksforgeeks.org/program-for-point-of-intersection-of-two-lines
  232|      2|bool isOnLine(Point a, Point b, Point intersect){
  233|      2|    
  234|      2|    double ax, bx, ay, by;
  235|      2|    
  236|      2|    //Determine max and min x values
  237|      2|    if(a.x >= b.x){
  238|      1|        ax = b.x;
  239|      1|        bx = a.x;
  240|      1|        
  241|      1|    } else {
  242|      1|        ax = a.x;
  243|      1|        bx = b.x;
  244|      1|    }
  245|      2|    
  246|      2|    //Determine max and min y values
  247|      2|    if(a.y >= b.y){
  248|      2|        ay = b.y;
  249|      2|        by = a.y;
  250|      2|        
  251|      2|    } else {
  252|      0|        ay = a.y;
  253|      0|        by = b.y;
  254|      0|    }
  255|      2|    
  256|      2|    //Determine if intersect is on line
  257|      2|    if(ax <= intersect.x && intersect.x <= bx && ay <= intersect.y && intersect.y <= by){
  258|      0|        return true;
  259|      0|    }
  260|      2|    
  261|      2|    return false;
  262|      2|}
  263|       |
  264|       |//Modified from www.geeksforgeeks.org/program-for-point-of-intersection-of-two-lines
  265|      7|void checkLineColl(Point a, Point b, Point c, Point d){
  266|      7|    
  267|      7|    //Line AB = c1 = a1x + b1y
  268|      7|    double a1 = c.y - b.y; //expect 1
  269|      7|    double b1 = b.x - c.x; //expect -7
  270|      7|    double c1 = a1*(b.x) + b1*(b.y); //expect -60
  271|      7|    
  272|      7|    //Line CD = c2 = a2x + b2y
  273|      7|    double a2 = a.y - d.y; //expect -3
  274|      7|    double b2 = d.x - a.x; //expect 9
  275|      7|    double c2 = a2*(d.x) + b2*(d.y); //expect 0
  276|      7|    
  277|      7|    double determinant = a1*b2 - a2*b1; //expect -12
  278|      7|    
  279|      7|    if(determinant != 0){
  280|      2|        double x = (b2*c1 - b1*c2)/determinant; //expect 45
  281|      2|        double y = (a1*c2 - a2*c1)/determinant; //expect 15
  282|      2|        Point intersect = {x,y};
  283|      2|        
  284|      2|        if(isOnLine(b,c,intersect) && isOnLine(d,a,intersect)){
  285|      0|            error("error 3");
  286|      0|            exit(1);
  287|      0|        }
  288|      2|        
  289|      2|    }
  290|      7|    
  291|      7|}
  292|       |
  293|       |//Modified from www.geeksforgeeks.org/program-check-three-points-collinear
  294|     28|double calcTriArea(Point a, Point b, Point c){
  295|     28|    return a.x * (b.y-c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y);
  296|     28|}
  297|       |
  298|      7|void checkCollinear(Point a, Point b, Point c, Point d){
  299|      7|    
  300|      7|    if(calcTriArea(a,b,c) == 0 || calcTriArea(b,c,d) == 0 || calcTriArea(c,d,a) == 0 || calcTriArea(d,a,b) == 0){
  301|      0|        error("error 4");
  302|      0|        exit(1);
  303|      0|    }
  304|      7|    
  305|      7|}
  306|       |
  307|    107|void checkForErrors(Point a, Point b, Point c, Point d){
  308|    107|    
  309|    107|    //Confirm no points are the same
  310|    107|    checkPointColl(a,b,c,d);
  311|    107|    
  312|    107|    //Confirm no lines cross
  313|    107|    checkLineColl(a,b,c,d);
  314|    107|    
  315|    107|    //Confirm no 3 points are collinear
  316|    107|    checkCollinear(a,b,c,d);
  317|    107|    
  318|    107|}
  319|       |
  320|    207|std::vector<std::string> parseLine(std::string line){
  321|    207|    
  322|    207|    std::stringstream ss(line);
  323|    207|    std::string value;
  324|    207|    std::vector<std::string> parsed;
  325|  1.44k|    while (std::getline(ss, value, ' '))
  326|  1.24k|    {
  327|  1.24k|        parsed.push_back(value);
  328|  1.24k|    }
  329|    207|    
  330|    207|    checkLength(parsed);
  331|    207|    
  332|    207|    return parsed;
  333|    207|    
  334|    207|}
  335|       |
  336|       |/*
  337|       | * DATA INPUT FXNS
  338|       | * Stores user inputted quadrilateral data
  339|       | */
  340|       |
  341|       |//Stores a quadrilateral
  342|      7|Quad storeQuad(Point a, Point b, Point c, Point d){
  343|      7|    
  344|      7|    Angle angA = {d,a,b, calcDeg(d,a,b)};
  345|      7|    Angle angB = {a,b,c, calcDeg(a,b,c)};
  346|      7|    Angle angC = {b,c,d, calcDeg(b,c,d)};
  347|      7|    Angle angD = {c,d,a, calcDeg(c,b,a)};
  348|      7|    
  349|      7|    Quad quad = {calcLength(a,b), calcLength(b,c), calcLength(c,d), calcLength(d,a), angA, angB, angC, angD};
  350|      7|    
  351|      7|    return quad;
  352|      7|    
  353|      7|}
  354|       |
  355|       |//Stores input data
  356|    207|std::vector<Quad> storeInputData(){
  357|    207|    
  358|    207|    std::vector<Quad> data;
  359|    207|    
  360|    414|    while(!std::cin.eof()){
  361|    207|        
  362|    207|        //Input line
  363|    207|        std::string line;
  364|    207|        getline(std::cin, line);
  365|    207|        
  366|    207|        //Parse line
  367|    207|        std::vector<std::string> parsed = parseLine(line);
  368|    207|        
  369|    207|        //Convert to digits
  370|    207|        double digits[6];
  371|  1.14k|        for(int i = 0; i < parsed.size(); i++){
  372|    942|            
  373|    942|            if(isdigit(parsed[i][0])){
  374|    842|                double digit = stoi(parsed[i]);
  375|    842|                digits[i] = digit;
  376|    842|            } else {
  377|    100|                error("error 1");
  378|    100|            }
  379|    942|        }
  380|    207|        
  381|    207|        checkRange(digits);
  382|    207|        
  383|    207|        Point a = {0,0};
  384|    207|        Point b = {digits[0],digits[1]};
  385|    207|        Point c = {digits[2],digits[3]};
  386|    207|        Point d = {digits[4],digits[5]};
  387|    207|        
  388|    207|        //Check points
  389|    207|        checkForErrors(a, b, c, d);
  390|    207|        
  391|    207|        data.push_back(storeQuad(a, b, c, d));
  392|    207|        
  393|    207|    }
  394|    207|    
  395|    207|    return data;
  396|    207|    
  397|    207|}
  398|       |
  399|       |/*
  400|       | * MAIN
  401|       | */
  402|       |
  403|    207|int main() {
  404|    207|    
  405|    207|    //Store data points from file
  406|    207|    std::vector<Quad> data = storeInputData();
  407|    207|    
  408|    207|    //Classify each quadrilateral
  409|    214|    for(int i = 0; i < data.size(); i++){
  410|      7|        classifyQuad(data[i]);
  411|      7|    }
  412|    207|    
  413|    207|    return 0;
  414|    207|    
  415|    207|}

